Профилирование Java
Инструменты:
1. jps - Показывает приложение и его pid
2. jmap - Утилита позволяет увидеть какие объекты созданы, какие ожидают удаления
3. jmap -histo <pid> - Видим, какие объекты созданы и в каком количестве
4. jstat - предоставляет сводную информацию о состоянии памяти программы.
5. jstat -gc pid 1s 10 - В данном случае мы делаем сэмплинг каждую секунду в течении 10 секунд. Флаг -gc указывает на то, что мы хотим увидеть различные области памяти
6. jconsole - программа для профилирования.

Анализ:
1. Порядок выполнения программы. Добавление и удаление 1_000_000 заявок (action.png)
2. jconsole - первый подъем в графике добавление 1_000_000 заявок, второй подъем в графике удаление всех заявок (jconsole.png)
3. jstat - три запуска информации о состоянии памяти, первый при запуске, второй при добавлении 1_000_000 заявок, третий при удалении всех заявок (jstat.png)
3. jmap -histo - три запуска информации о состоянии объектов, первый при запуске (jmap_first.png), второй при добавлении 1_000_000 заявок (jmap_second.png), третий при удалении всех заявок (jmap_third.png)
Как видно из последнего скриншота (jmap_third.png) объекты еще остались, т.е. удаление объектов не гарантирует их моментально очистку GC.
В строке 6 объекты остались
6:       1000000       24000000  ru.job4j.tracker.Item

Выход за пределы памяти:
1. Указали хранилище как SqlTracker, т.е. будет подключение к бд
2. Добавили 100000 заявок, затем удалили все заявки (out_of_memory_error_1.png) и поймали java.lang.OutOfMemoryError
3. Анализ состояния на момент падения (out_of_memory_error_2.png) и (out_of_memory_error_3.png)
4. Вывод: память heap кончилась при действии удаления всех заявок, а именно на моменте поиска всех заявок (at ru.job4j.tracker.SqlTracker.findAll(SqlTracker.java:93)). Этот метод требует оптимизации.